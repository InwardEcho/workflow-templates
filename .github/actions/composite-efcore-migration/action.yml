# Composite Action for Entity Framework Core Database Migration
# Filename: .github/actions/composite-efcore-migration/action.yml
# Purpose: Manages EF Core database schema migrations.

name: 'Composite EF Core Database Migration'
description: 'A composite action to apply Entity Framework Core database migrations.'

inputs:
  efcore-project-path:
    description: 'Path to the .csproj file containing EF Core DbContext and migrations.'
    required: true
  environment-name:
    description: 'Target environment-name name (e.g., dev, test, prod).'
    required: true
  backup-required:
    description: 'Whether a database backup should be attempted before migration.'
    required: false
    default: 'false' # String for composite action
  backup-script-path:
    description: 'Path to a custom database backup script.'
    required: false
    default: ''
  migration-timeout:
    description: 'Timeout for the `dotnet ef database update` command (e.g., 5m, 10m).'
    required: false
    default: '5m'
  dotnet-version:
    description: '.NET SDK version to use for EF Core tools.'
    required: false
    default: '7.0.x'
  migration_script_path:
    description: 'Optional path to a pre-generated SQL migration script. If provided, this script will be applied using sqlcmd.'
    required: false
    default: ''
  # sql_server:
  #   description: 'SQL Server name/address. Required if migration_script_path is provided.'
  #   required: false
  # sql_database:
  #   description: 'SQL Database name. Required if migration_script_path is provided.'
  #   required: false
  # sql_user:
  #   description: 'SQL User name. Required if migration_script_path is provided.'
  #   required: false
  # sql_password:
  #   description: 'SQL Password. Required if migration_script_path is provided. Should be a secret.'
  #   required: false
  # DB_CONNECTION_STRING is a secret, handled via env context for dotnet ef path

outputs:
  status:
    description: "Status of the database migration process ('success' or 'failure')."
    value: ${{ steps.set_final_status.outputs.status }}
  backup_status:
    description: "Status of the backup step ('success', 'failure', or 'skipped')."
    value: ${{ steps.backup_database.outcome || 'skipped' }}
  migration_apply_status:
    description: "Status of applying migrations ('success', 'failure', or 'skipped')."
    value: ${{ steps.apply_sql_script.outcome || steps.apply_ef_cli.outcome || 'skipped' }}

runs:
  using: "composite"
  steps:

    - name: Setup .NET SDK
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ inputs.dotnet-version }}

    - name: Install EF Core Tools
      shell: bash
      run: |
        DOTNET_MAJOR_MINOR=$(echo "${{ inputs.dotnet-version }}" | cut -d'.' -f1,2)
        echo "Installing EF Core tools for .NET $DOTNET_MAJOR_MINOR"
        # Installs the latest patch version of EF tools compatible with the major.minor SDK version
        dotnet tool install --global dotnet-ef --version $DOTNET_MAJOR_MINOR.*
        # Ensure EF tools are on the PATH (usually handled by setup-dotnet or tool installer)
        echo "$HOME/.dotnet/tools" >> $GITHUB_PATH

    - name: Install SQLCMD Tools
      id: install_sqlcmd
      if: inputs.migration_script_path != '' && inputs.migration_script_path != null
      shell: bash
      run: |
        echo "Attempting to install mssql-tools..."
        
        # Clean up any existing Microsoft repositories to avoid duplicates
        sudo rm -f /etc/apt/sources.list.d/mssql-release.list
        sudo rm -f /etc/apt/sources.list.d/microsoft-prod.list
        
        # Add Microsoft signing key (using the new recommended method)
        curl -sSL https://packages.microsoft.com/keys/microsoft.asc | sudo tee /etc/apt/trusted.gpg.d/microsoft.asc
        
        # Use Ubuntu 22.04 repository (jammy) since 24.04 may not be supported yet
        echo "deb [arch=amd64,arm64,armhf] https://packages.microsoft.com/ubuntu/22.04/prod jammy main" | sudo tee /etc/apt/sources.list.d/mssql-release.list
        
        # Update package list
        sudo apt-get update
        
        # Install SQL Server tools
        sudo ACCEPT_EULA=Y apt-get install -y mssql-tools18 unixodbc-dev
        
        # Add to PATH
        echo "/opt/mssql-tools18/bin" >> $GITHUB_PATH
        
        # Verify installation
        /opt/mssql-tools18/bin/sqlcmd -? || (echo "::error::sqlcmd not found after installation" && exit 1)


    - name: Backup Database (Optional)
      id: backup_database
      if: inputs.backup-required == 'true'
      shell: bash
      run: |
        echo "Attempting database backup for environment-name: ${{ inputs.environment-name }}"
        if [[ -n "${{ inputs.backup-script-path }}" && -f "${{ inputs.backup-script-path }}" ]]; then
          echo "Running custom backup script: ${{ inputs.backup-script-path }}"
          # Ensure the script is executable
          chmod +x "${{ inputs.backup-script-path }}"
          # Execute the script. It should handle its own success/failure reporting.
          # Example: ./${{ inputs.backup-script-path }}
          echo "::warning::Custom backup script ('${{ inputs.backup-script-path }}') execution logic placeholder."
          # For testing, assume success if script exists, otherwise fail
          # if ./"${{ inputs.backup-script-path }}"; then echo "Custom backup script succeeded."; else echo "::error::Custom backup script failed."; exit 1; fi
        else
          echo "::warning::No custom backup script provided or found at '${{ inputs.backup-script-path }}'. Placeholder for generic backup."
          echo "Generic backup logic would go here. Simulating successful backup for now."
        fi
      env:
        # The script should use this environment-name variable
        DB_CONNECTION_STRING_FOR_BACKUP: ${{ env.DB_CONNECTION_STRING }}
      continue-on-error: false # Backup failure should stop the process if backup is required

    - name: Apply SQL Migration Script
      id: apply_sql_script
      if: >
        ((inputs.backup-required == 'false') || (inputs.backup-required == 'true' && steps.backup_database.outcome == 'success')) &&
        inputs.migration_script_path != '' && inputs.migration_script_path != null
      shell: bash
      run: |
        # Install sqlparse library for proper connection string parsing
        pip3 install sqlparse urllib3
        
        # Use Python with proper parsing
        python3 << 'EOF'
        import urllib.parse
        import subprocess
        import sys
        import os

        conn_str = os.environ.get('DB_CONNECTION_STRING', '')

        # Parse connection string properly
        # Split by semicolon and create dict
        params = {}
        for pair in conn_str.split(';'):
            if '=' in pair and pair.strip():
                key, value = pair.split('=', 1)
                params[key.strip()] = value.strip()

        # Extract with proper key mapping
        server_key = next((k for k in params.keys() if k.lower() in ['server', 'data source']), None)
        db_key = next((k for k in params.keys() if k.lower() in ['initial catalog', 'database']), None)
        user_key = next((k for k in params.keys() if k.lower() in ['user id', 'uid']), None)
        pwd_key = next((k for k in params.keys() if k.lower() in ['password', 'pwd']), None)

        if not all([server_key, db_key, user_key, pwd_key]):
            print("Error: Could not find required connection string parameters")
            sys.exit(1)

        server = params[server_key].replace('tcp:', '').split(',')[0]  # Remove tcp: and port
        database = params[db_key]
        user = params[user_key]
        password = params[pwd_key]

        print(f"Applying SQL migration script to {database} on {server}")

        # Run sqlcmd
        cmd = [
            'sqlcmd',
            '-S', server,
            '-d', database, 
            '-U', user,
            '-P', password,
            '-i', os.environ.get('MIGRATION_SCRIPT_PATH', ''),
            '-b', '-C'
        ]

        result = subprocess.run(cmd, capture_output=True, text=True)
        print(result.stdout)
        if result.stderr:
            print(result.stderr, file=sys.stderr)
            
        sys.exit(result.returncode)
        EOF
      env:
        DB_CONNECTION_STRING: ${{ env.DB_CONNECTION_STRING }}
        MIGRATION_SCRIPT_PATH: ${{ inputs.migration_script_path }}
      continue-on-error: false


    # - name: Apply SQL Migration Script
    #   id: apply_sql_script
    #   if: >
    #     ((inputs.backup-required == 'false') || (inputs.backup-required == 'true' && steps.backup_database.outcome == 'success')) &&
    #     inputs.migration_script_path != '' && inputs.migration_script_path != null
    #   shell: bash
    #   run: |
    #     # Example connection string
    #     CONNECTION_STRING="${{ env.DB_CONNECTION_STRING }}"
        
    #     # Parse connection string (example for common formats)
    #     if [[ $CONNECTION_STRING == *"Server="* ]]; then
    #       # Parse .NET style connection string
    #       SERVER=$(echo "$CONNECTION_STRING" | grep -oP 'Server=\K[^;]*')
    #       DATABASE=$(echo "$CONNECTION_STRING" | grep -oP 'Database=\K[^;]*')
    #       USER=$(echo "$CONNECTION_STRING" | grep -oP 'User Id=\K[^;]*' || echo "$CONNECTION_STRING" | grep -oP 'Uid=\K[^;]*')
    #       PASSWORD=$(echo "$CONNECTION_STRING" | grep -oP 'Password=\K[^;]*' || echo "$CONNECTION_STRING" | grep -oP 'Pwd=\K[^;]*')
    #     elif [[ $CONNECTION_STRING == *"server="* ]]; then
    #       # Parse lowercase version
    #       SERVER=$(echo "$CONNECTION_STRING" | grep -oP 'server=\K[^;]*')
    #       DATABASE=$(echo "$CONNECTION_STRING" | grep -oP 'database=\K[^;]*')
    #       USER=$(echo "$CONNECTION_STRING" | grep -oP 'user id=\K[^;]*' || echo "$CONNECTION_STRING" | grep -oP 'uid=\K[^;]*')
    #       PASSWORD=$(echo "$CONNECTION_STRING" | grep -oP 'password=\K[^;]*' || echo "$CONNECTION_STRING" | grep -oP 'pwd=\K[^;]*')
    #     fi
        
    #     # Run sqlcmd with parsed parameters
    #     sqlcmd -S "$SERVER" -d "$DATABASE" -U "$USER" -P "$PASSWORD" -i "${{ inputs.migration_script_path }}" -b -C
    #   env:
    #     # The script should use this environment-name variable
    #     DB_CONNECTION_STRING_FOR_BACKUP: ${{ env.DB_CONNECTION_STRING }}
    #   continue-on-error: false

    - name: Apply EF Core Migrations via CLI
      id: apply_ef_cli
      if: >
        ((inputs.backup-required == 'false') || (inputs.backup-required == 'true' && steps.backup_database.outcome == 'success')) &&
        (inputs.migration_script_path == '' || inputs.migration_script_path == null)
      shell: bash
      run: |
        echo "Applying EF Core migrations to ${{ inputs.environment-name }} database via CLI..."
        echo "Project path: ${{ inputs.efcore-project-path }}"
        timeout ${{ inputs.migration-timeout }} dotnet ef database update --project "${{ inputs.efcore-project-path }}" --verbose
      env:
        ConnectionStrings__DefaultConnection: ${{ env.DB_CONNECTION_STRING }}
      continue-on-error: false

    - name: Set Final Status
      id: set_final_status
      shell: bash
      run: |
        FINAL_STATUS="success"
        MIGRATION_STEP_OUTCOME=""
        # Determine which migration step was attempted
        if [[ -n "${{ inputs.migration_script_path }}" && "${{ inputs.migration_script_path }}" != "" ]]; then
          MIGRATION_STEP_OUTCOME="${{ steps.apply_sql_script.outcome }}"
        else
          MIGRATION_STEP_OUTCOME="${{ steps.apply_ef_cli.outcome }}"
        fi

        # Check backup step outcome if it was supposed to run
        if [[ "${{ inputs.backup-required }}" == "true" && "${{ steps.backup_database.outcome }}" == "failure" ]]; then
          FINAL_STATUS="failure"
          echo "::error::Database backup step failed."
        # Check migration step outcome
        elif [[ "$MIGRATION_STEP_OUTCOME" == "failure" ]]; then
          FINAL_STATUS="failure"
          echo "::error::Applying migrations failed (Outcome: $MIGRATION_STEP_OUTCOME)."
        # Check if migrations were skipped because a required backup didn't succeed
        elif [[ "$MIGRATION_STEP_OUTCOME" == "skipped" && \
                "${{ inputs.backup-required }}" == "true" && \
                "${{ steps.backup_database.outcome }}" != "success" ]]; then
          FINAL_STATUS="failure"
          echo "::error::Migrations skipped due to the backup step not succeeding (Backup outcome: ${{ steps.backup_database.outcome }})."
        fi
        echo "status=$FINAL_STATUS" >> $GITHUB_OUTPUT
      if: always() # This step must always run to set the output