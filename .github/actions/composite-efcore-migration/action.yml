# Composite Action for Entity Framework Core Database Migration
# Filename: .github/actions/composite-efcore-migration/action.yml
# Purpose: Manages EF Core database schema migrations.

name: 'Composite EF Core Database Migration'
description: 'A composite action to apply Entity Framework Core database migrations.'

inputs:
  efcore-project-path:
    description: 'Path to the .csproj file containing EF Core DbContext and migrations.'
    required: true
  environment-name:
    description: 'Target environment-name name (e.g., dev, test, prod).'
    required: true
  backup-required:
    description: 'Whether a database backup should be attempted before migration.'
    required: false
    default: 'false' # String for composite action
  backup-script-path:
    description: 'Path to a custom database backup script.'
    required: false
    default: ''
  migration-timeout:
    description: 'Timeout for the `dotnet ef database update` command (e.g., 5m, 10m).'
    required: false
    default: '5m'
  dotnet-version:
    description: '.NET SDK version to use for EF Core tools.'
    required: false
    default: '7.0.x'
  migration_script_path:
    description: 'Optional path to a pre-generated SQL migration script. If provided, this script will be applied using sqlcmd.'
    required: false
    default: ''
  sql_server:
    description: 'SQL Server name/address. Required if migration_script_path is provided.'
    required: false
  sql_database:
    description: 'SQL Database name. Required if migration_script_path is provided.'
    required: false
  sql_user:
    description: 'SQL User name. Required if migration_script_path is provided.'
    required: false
  sql_password:
    description: 'SQL Password. Required if migration_script_path is provided. Should be a secret.'
    required: false
  # DB_CONNECTION_STRING is a secret, handled via env context for dotnet ef path

outputs:
  status:
    description: "Status of the database migration process ('success' or 'failure')."
    value: ${{ steps.set_final_status.outputs.status }}
  backup_status:
    description: "Status of the backup step ('success', 'failure', or 'skipped')."
    value: ${{ steps.backup_database.outcome || 'skipped' }}
  migration_apply_status:
    description: "Status of applying migrations ('success', 'failure', or 'skipped')."
    value: ${{ steps.apply_sql_script.outcome || steps.apply_ef_cli.outcome || 'skipped' }}

runs:
  using: "composite"
  steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup .NET SDK
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ inputs.dotnet-version }}

    - name: Install EF Core Tools
      shell: bash
      run: |
        DOTNET_MAJOR_MINOR=$(echo "${{ inputs.dotnet-version }}" | cut -d'.' -f1,2)
        echo "Installing EF Core tools for .NET $DOTNET_MAJOR_MINOR"
        # Installs the latest patch version of EF tools compatible with the major.minor SDK version
        dotnet tool install --global dotnet-ef --version $DOTNET_MAJOR_MINOR.*
        # Ensure EF tools are on the PATH (usually handled by setup-dotnet or tool installer)
        echo "$HOME/.dotnet/tools" >> $GITHUB_PATH

    - name: Install SQLCMD Tools
      id: install_sqlcmd
      if: inputs.migration_script_path != '' && inputs.migration_script_path != null
      shell: bash
      run: |
        echo "Attempting to install mssql-tools..."
        # Add Microsoft SQL Server repository
        curl https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add -
        curl https://packages.microsoft.com/config/ubuntu/$(lsb_release -rs)/prod.list | sudo tee /etc/apt/sources.list.d/mssql-release.list
        sudo apt-get update
        # Install SQL Server tools
        sudo ACCEPT_EULA=Y apt-get install -y mssql-tools unixodbc-dev
        echo "/opt/mssql-tools/bin" >> $GITHUB_PATH
        sqlcmd -? || (echo "::error::sqlcmd not found after attempting install" && exit 1)

    - name: Backup Database (Optional)
      id: backup_database
      if: inputs.backup-required == 'true'
      shell: bash
      run: |
        echo "Attempting database backup for environment-name: ${{ inputs.environment-name }}"
        if [[ -n "${{ inputs.backup-script-path }}" && -f "${{ inputs.backup-script-path }}" ]]; then
          echo "Running custom backup script: ${{ inputs.backup-script-path }}"
          # Ensure the script is executable
          chmod +x "${{ inputs.backup-script-path }}"
          # Execute the script. It should handle its own success/failure reporting.
          # Example: ./${{ inputs.backup-script-path }}
          echo "::warning::Custom backup script ('${{ inputs.backup-script-path }}') execution logic placeholder."
          # For testing, assume success if script exists, otherwise fail
          # if ./"${{ inputs.backup-script-path }}"; then echo "Custom backup script succeeded."; else echo "::error::Custom backup script failed."; exit 1; fi
        else
          echo "::warning::No custom backup script provided or found at '${{ inputs.backup-script-path }}'. Placeholder for generic backup."
          echo "Generic backup logic would go here. Simulating successful backup for now."
        fi
      env:
        # The script should use this environment-name variable
        DB_CONNECTION_STRING_FOR_BACKUP: ${{ env.DB_CONNECTION_STRING }}
      continue-on-error: false # Backup failure should stop the process if backup is required

    - name: Apply SQL Migration Script
      id: apply_sql_script
      if: >
        ((inputs.backup-required == 'false') || (inputs.backup-required == 'true' && steps.backup_database.outcome == 'success')) &&
        inputs.migration_script_path != '' && inputs.migration_script_path != null
      shell: bash
      run: |
        echo "Applying SQL migration script: ${{ inputs.migration_script_path }} to ${{ inputs.sql_database }} on ${{ inputs.sql_server }}"
        sqlcmd -S "${{ inputs.sql_server }}" -d "${{ inputs.sql_database }}" -U "${{ inputs.sql_user }}" -P "${{ inputs.sql_password }}" -i "${{ inputs.migration_script_path }}" -b -C
      continue-on-error: false

    - name: Apply EF Core Migrations via CLI
      id: apply_ef_cli
      if: >
        ((inputs.backup-required == 'false') || (inputs.backup-required == 'true' && steps.backup_database.outcome == 'success')) &&
        (inputs.migration_script_path == '' || inputs.migration_script_path == null)
      shell: bash
      run: |
        echo "Applying EF Core migrations to ${{ inputs.environment-name }} database via CLI..."
        echo "Project path: ${{ inputs.efcore-project-path }}"
        timeout ${{ inputs.migration-timeout }} dotnet ef database update --project "${{ inputs.efcore-project-path }}" --verbose
      env:
        ConnectionStrings__DefaultConnection: ${{ env.DB_CONNECTION_STRING }}
      continue-on-error: false

    - name: Set Final Status
      id: set_final_status
      shell: bash
      run: |
        FINAL_STATUS="success"
        MIGRATION_STEP_OUTCOME=""
        # Determine which migration step was attempted
        if [[ -n "${{ inputs.migration_script_path }}" && "${{ inputs.migration_script_path }}" != "" ]]; then
          MIGRATION_STEP_OUTCOME="${{ steps.apply_sql_script.outcome }}"
        else
          MIGRATION_STEP_OUTCOME="${{ steps.apply_ef_cli.outcome }}"
        fi

        # Check backup step outcome if it was supposed to run
        if [[ "${{ inputs.backup-required }}" == "true" && "${{ steps.backup_database.outcome }}" == "failure" ]]; then
          FINAL_STATUS="failure"
          echo "::error::Database backup step failed."
        # Check migration step outcome
        elif [[ "$MIGRATION_STEP_OUTCOME" == "failure" ]]; then
          FINAL_STATUS="failure"
          echo "::error::Applying migrations failed (Outcome: $MIGRATION_STEP_OUTCOME)."
        # Check if migrations were skipped because a required backup didn't succeed
        elif [[ "$MIGRATION_STEP_OUTCOME" == "skipped" && \
                "${{ inputs.backup-required }}" == "true" && \
                "${{ steps.backup_database.outcome }}" != "success" ]]; then
          FINAL_STATUS="failure"
          echo "::error::Migrations skipped due to the backup step not succeeding (Backup outcome: ${{ steps.backup_database.outcome }})."
        fi
        echo "status=$FINAL_STATUS" >> $GITHUB_OUTPUT
      if: always() # This step must always run to set the output