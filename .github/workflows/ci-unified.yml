# Unified Continuous Integration Workflow
# Filename: .github/workflows/ci-unified.yml
# Purpose: Handles CI for various branches, including versioning, build, test, package,
#          and triggering CD for DEV environment.

name: Unified CI

on:
  workflow_call:
    inputs:
      logLevel:
        description: 'Log level for the CI process'
        required: false
        type: string # Even if conceptually a choice, workflow_call inputs are string, boolean, or number
        default: 'warning'
      # Potentially add other inputs if parts of this CI pipeline should be configurable by the caller
      # For example:
      # solution_path:
      #   description: 'Path to the .sln file for the build'
      #   required: false
      #   type: string
      #   default: '**/*.sln' # Default to how it's used in version_and_build job
      # dotnet_version_to_use:
      #   description: 'Specific .NET SDK version to use for build/test'
      #   required: false
      #   type: string
      #   default: '8.0.x' # Default to how it's used in version_and_build job

    secrets:
      NUGET_FEED_AUTH_TOKEN_CI:
        description: 'Optional NuGet feed authentication token for restoring packages during CI.'
        required: false
      WORKFLOW_DISPATCH_PAT:
        description: 'PAT with workflow write scope, required to trigger the DEV deployment workflow.'
        required: true # This is used in the trigger_dev_deployment job
      SLACK_WEBHOOK_URL_CI:
        description: 'Slack Webhook URL for CI notifications.'
        required: false # Set to true if notifications are mandatory

permissions:
  contents: read      # To checkout code
  actions: write       # To trigger cd-dev-environment.yml via workflow_dispatch (if this reusable workflow still does that directly)
                       # Or, if the calling workflow should handle triggering other workflows, this might change.
  # packages: write    # If this workflow were to directly publish packages (but it uses reusable-publish-nuget)

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  # Example: Define a common variable for artifact storage if needed across jobs
  # ARTIFACT_STORAGE_PATH: './artifacts'

jobs:
  initialize_ci:
    name: Initialize CI & Determine Variables
    runs-on: ubuntu-latest
    outputs:
      is_main_branch: ${{ steps.determine_branch.outputs.is_main }}
      versioning_strategy: ${{ steps.determine_branch.outputs.version_strategy }}
      version_prerelease_suffix: ${{ steps.determine_branch.outputs.prerelease_suffix }}
      nuget_publish_feed_type: ${{ steps.determine_branch.outputs.nuget_feed_type }} # e.g., 'release' or 'prerelease'
      build_artifact_prefix: ${{ steps.determine_branch.outputs.artifact_prefix }} # e.g., 'release' or 'feature'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # For GitVersion or full history

      - name: Determine Branch Type and CI Variables
        id: determine_branch
        shell: bash
        run: |
          IS_MAIN="false"
          VERSION_STRATEGY="gitversion" # Default strategy
          PRERELEASE_SUFFIX=""
          NUGET_FEED_TYPE="prerelease" 
          ARTIFACT_PREFIX="feature" # Default prefix for artifacts

          REF_NAME="${{ github.ref_name }}" # e.g., main, feature/foo, hotfix/bar

          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            IS_MAIN="true"
            NUGET_FEED_TYPE="release"
            ARTIFACT_PREFIX="release"
            # No PRERELEASE_SUFFIX for main, GitVersion will handle release versioning
          elif [[ "$REF_NAME" == hotfix/* ]]; then
            # For hotfix branches, GitVersion might produce a suitable prerelease tag.
            # If specific suffix needed, it can be set here.
            # PRERELEASE_SUFFIX=$(echo "$REF_NAME" | sed 's|hotfix/||' | sed 's/[^a-zA-Z0-9.-]/-/g' | sed 's/--*/-/g' | sed 's/^-//g' | sed 's/-$//g')
            ARTIFACT_PREFIX="hotfix"
          else # feature, bugfix branches
            # For feature/bugfix, GitVersion will typically create a prerelease tag like 'alpha', 'beta' + branch name.
            # If an additional explicit suffix is desired, it can be constructed here.
            # PRERELEASE_SUFFIX=$(echo "$REF_NAME" | sed 's|feature/||' | sed 's|bugfix/||' | sed 's/[^a-zA-Z0-9.-]/-/g' | sed 's/--*/-/g' | sed 's/^-//g' | sed 's/-$//g')
            # if [[ -z "$PRERELEASE_SUFFIX" ]]; then PRERELEASE_SUFFIX="dev"; fi
            : # Using GitVersion's default prerelease naming for feature/bugfix
          fi
          
          echo "is_main=$IS_MAIN" >> $GITHUB_OUTPUT
          echo "version_strategy=$VERSION_STRATEGY" >> $GITHUB_OUTPUT
          echo "prerelease_suffix=$PRERELEASE_SUFFIX" >> $GITHUB_OUTPUT # This might be used by reusable-versioning if it supports appending
          echo "nuget_feed_type=$NUGET_FEED_TYPE" >> $GITHUB_OUTPUT
          echo "artifact_prefix=$ARTIFACT_PREFIX" >> $GITHUB_OUTPUT

  version_and_build:
    name: Version, Build & Test
    runs-on: ubuntu-latest
    needs: initialize_ci
    outputs:
      calculated_version: ${{ steps.version.outputs.calculated-version }}
      build_test_status: ${{ steps.build_test.outputs.status }}
      build_artifact_name: ${{ steps.build_test.outputs.build-artifact-name }} # Name of the .zip package artifact
      test_results_artifact_name: ${{ steps.build_test.outputs.test-results-artifact-name }}
      published_output_path: ${{ steps.build_test.outputs.published-output-path }} # Path where dotnet publish placed files

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            6.0.x
            7.0.x
            8.0.x

      - name: Calculate Version
        id: version
        uses: ./.github/workflows/reusable-versioning.yml
        with:
          strategy: ${{ needs.initialize_ci.outputs.versioning_strategy }}
          prerelease-suffix-override: ${{ needs.initialize_ci.outputs.version_prerelease_suffix }} # Pass determined suffix
          fetch-depth: 0 # Ensure full history for GitVersion

      - name: Build, Test, and Package Application
        id: build_test
        uses: ./.github/workflows/reusable-build-test-dotnet.yml
        with:
          solution-path: '**/*.sln'
          build-configuration: 'Release'
          dotnet-version-to-use: '8.0.x' # Or from matrix/input
          run-tests: true
          package-application: true # Always package in this CI workflow
          publish-output-directory: './app-publish' # Standard output path for packaged app
          artifact-name-prefix: ${{ needs.initialize_ci.outputs.build_artifact_prefix }}-${{ steps.version.outputs.calculated-version }}
          upload-build-artifacts: true # Upload the packaged application as an artifact
          upload-test-results-artifact: true
          NUGET_FEED_AUTH_TOKEN: ${{ secrets.NUGET_FEED_AUTH_TOKEN_CI }} # Optional, if restore needs private feeds

  publish_package:
    name: Publish NuGet Package
    runs-on: ubuntu-latest
    needs: [initialize_ci, version_and_build]
    if: needs.version_and_build.outputs.build_test_status == 'success' && needs.version_and_build.outputs.calculated_version != ''
    outputs:
      nuget_publish_status: ${{ steps.publish_nuget.outputs.status }}
      published_nuget_packages_count: ${{ steps.publish_nuget.outputs.published-count }}

    steps:
      - name: Download Published Application Artifact (contains .nupkg)
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.version_and_build.outputs.build_artifact_name }} # This is the .zip artifact
          path: ${{ needs.version_and_build.outputs.published_output_path }} # Download to the publish output path

      - name: Publish NuGet Package
        id: publish_nuget
        uses: ./.github/workflows/reusable-publish-nuget.yml
        with:
          working-directory: ${{ needs.version_and_build.outputs.published_output_path }} # Assume .nupkg are at the root of the published output
          package-path: '*.nupkg' # Search for .nupkg files in the downloaded artifact path
          version: ${{ needs.version_and_build.outputs.calculated_version }}
          nuget-feed-url: "https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json" # Default to GitHub Packages for the org/user
          is-prerelease: ${{ needs.initialize_ci.outputs.is_main_branch == 'false' }}
          skip-duplicate: true
          NUGET_API_KEY: ${{ secrets.GITHUB_TOKEN }} # Use GITHUB_TOKEN for GitHub Packages

  trigger_dev_deployment:
    name: Trigger DEV Deployment
    runs-on: ubuntu-latest
    needs: [initialize_ci, version_and_build, publish_package] # Depends on successful build and optional publish
    if: needs.version_and_build.outputs.build_test_status == 'success' # Only trigger if build was successful

    steps:
      - name: Dispatch DEV Deployment Workflow
        uses: benc-uk/workflow-dispatch@v1
        with:
          workflow: unified-cd-workflow.yml # Name of the CD workflow file
          token: ${{ secrets.WORKFLOW_DISPATCH_PAT }} # PAT with workflow write scope is required
          inputs: | # Use the pipe for a multi-line string, ensuring valid JSON
            {
              "version_to_deploy": "${{ needs.version_and_build.outputs.calculated_version }}",
              "source_artifact_name": "${{ needs.version_and_build.outputs.build_artifact_name }}"
            }
          ref: ${{ github.ref }} # Dispatch on the same ref/branch

  report_ci_status:
    name: Report CI Status
    runs-on: ubuntu-latest
    needs: [initialize_ci, version_and_build, publish_package, trigger_dev_deployment]
    if: always() # Run even if previous jobs fail to report the failure

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Calculate CI Status
        id: calculate_status
        run: |
          BUILD_SUCCESS=${{ needs.version_and_build.outputs.build_test_status == 'success' }}
          PUBLISH_SUCCESS=${{ needs.publish_package.result == 'success' || needs.publish_package.result == 'skipped' || needs.publish_package.result == '' }}
          DEPLOY_SUCCESS=${{ needs.trigger_dev_deployment.result == 'success' }}
          
          if [[ "$BUILD_SUCCESS" == "true" && "$PUBLISH_SUCCESS" == "true" && "$DEPLOY_SUCCESS" == "true" ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
          fi
      
      - name: Notify CI Status
        uses: ./.github/workflows/reusable-observability-hooks.yml
        with:
          status: ${{ steps.calculate_status.outputs.status }}
          workflow-name: "${{ github.workflow }} on ${{ github.ref_name }}"
          branch-name: ${{ github.ref_name }}
          commit-sha: ${{ github.sha }}
          run-url: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          message-details: |
            Version: `${{ needs.version_and_build.outputs.calculated_version }}`
            Build & Test: `${{ needs.version_and_build.outputs.build_test_status }}`
            NuGet Publish: `${{ needs.publish_package.outputs.nuget_publish_status || 'skipped' }}` (Published: `${{ needs.publish_package.outputs.published_nuget_packages_count || 0 }}`)
            DEV Dispatch Trigger: `${{ needs.trigger_dev_deployment.result }}`
          notification-channel: 'slack' # Or your preferred channel
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL_CI }}