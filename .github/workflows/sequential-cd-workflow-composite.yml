# Sequential Continuous Deployment Workflow (Refactored: Composite Actions)
# Purpose: Allows deployment to DEV, TEST, and PROD environments sequentially within a single workflow run,
# based on a user-selected deployment scope. Each environment is deployed in a single job using composite actions.
# Leverages GitHub Environments for secrets, approvals, and environment-specific configurations.

name: Sequential CD Workflow - Composite Actions

on:
  workflow_call:
    inputs:
      version_to_deploy:
        description: 'Version to deploy (e.g., 1.2.3 or 1.2.3-feature-xyz.5)'
        required: true
        type: string
      source_artifact_name:
        description: 'Name of the build artifact to download (e.g., release-1.2.3-app-package)'
        required: true
        type: string
      deployment_scope:
        description: 'Defines the sequence of environments to deploy to. Options: dev, test, dev-then-test, dev-then-test-then-prod, test-then-prod.'
        required: true
        type: string
      db_migration_project_path:
        description: 'DB migration project path'
        required: false
        type: string
      terraform_directory:
        description: 'Terraform directory path'
        required: false
        type: string
      dotnet_version:
        description: '.NET SDK version to use'
        required: false
        type: string
        default: '8.0.x'
    secrets:
      DB_CONNECTION_STRING:
        description: 'Database connection string for migrations'
        required: true
      AZURE_CREDENTIALS:
        description: 'Azure credentials for infrastructure deployment'
        required: true
      AZURE_CLIENT_ID:
        description: 'Azure Client ID'
        required: true
      AZURE_CLIENT_SECRET:
        description: 'Azure Client Secret'
        required: true
      AZURE_SUBSCRIPTION_ID:
        description: 'Azure Subscription ID'
        required: true
      AZURE_TENANT_ID:
        description: 'Azure Tenant ID'
        required: true
      

permissions:
  contents: read
  id-token: write      # For OIDC with cloud providers

concurrency:
  group: sequential-cd-composite-${{ github.event.inputs.deployment_scope }}-${{ github.event.inputs.version_to_deploy }}
  cancel-in-progress: false

env:
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true

jobs:
  determine_deployment_stages:
    name: Determine Deployment Stages
    runs-on: ubuntu-latest
    outputs:
      deploy_dev: ${{ steps.evaluate_scope.outputs.deploy_dev }}
      deploy_test: ${{ steps.evaluate_scope.outputs.deploy_test }}
      deploy_prod: ${{ steps.evaluate_scope.outputs.deploy_prod }}
      is_main_pipeline: ${{ steps.evaluate_scope.outputs.is_main_pipeline }}
      version: ${{ github.event.inputs.version_to_deploy }}
      artifact_name: ${{ github.event.inputs.source_artifact_name }}
      db_migration_project_path: ${{ github.event.inputs.db_migration_project_path }}
    steps:
      - name: Evaluate Deployment Scope
        id: evaluate_scope
        shell: bash
        run: |
          VERSION="${{ github.event.inputs.version_to_deploy }}"
          ARTIFACT_NAME="${{ github.event.inputs.source_artifact_name }}"
          DEPLOYMENT_SCOPE="${{ github.event.inputs.deployment_scope }}"
          
          DEPLOY_DEV="false"
          DEPLOY_TEST="false"
          DEPLOY_PROD="false"

          IS_MAIN_PIPELINE="false"
          if [[ "$ARTIFACT_NAME" == release-* ]]; then
            IS_MAIN_PIPELINE="true"
          fi

          echo "Deployment Scope: $DEPLOYMENT_SCOPE"
          echo "Version: $VERSION"
          echo "Artifact: $ARTIFACT_NAME"
          echo "Is Main Pipeline: $IS_MAIN_PIPELINE"

          case "$DEPLOYMENT_SCOPE" in
            dev)
              DEPLOY_DEV="true"
              ;;
            test)
              DEPLOY_TEST="true"
              ;;
            dev-then-test)
              DEPLOY_DEV="true"
              DEPLOY_TEST="true"
              ;;
            dev-then-test-then-prod)
              DEPLOY_DEV="true"
              DEPLOY_TEST="true"
              DEPLOY_PROD="true"
              ;;
            test-then-prod)
              DEPLOY_TEST="true"
              DEPLOY_PROD="true"
              ;;
            *)
              echo "::error::Invalid deployment_scope: $DEPLOYMENT_SCOPE"
              exit 1
              ;;
          esac

          echo "deploy_dev=$DEPLOY_DEV" >> $GITHUB_OUTPUT
          echo "deploy_test=$DEPLOY_TEST" >> $GITHUB_OUTPUT
          echo "deploy_prod=$DEPLOY_PROD" >> $GITHUB_OUTPUT
          echo "is_main_pipeline=$IS_MAIN_PIPELINE" >> $GITHUB_OUTPUT

          echo "Will deploy to DEV: $DEPLOY_DEV"
          echo "Will deploy to TEST: $DEPLOY_TEST"
          echo "Will deploy to PROD: $DEPLOY_PROD"

  plan_to_dev:
    name: 'Plan for DEV Environment'
    needs: determine_deployment_stages
    if: needs.determine_deployment_stages.outputs.deploy_dev == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        if: inputs.db_migration_project_path != ''
        with:
          dotnet-version: ${{ inputs.dotnet_version }}

      - name: Install EF Core Tools
        shell: bash
        if: inputs.db_migration_project_path != ''
        run: |
          dotnet tool install --global dotnet-ef
          echo "$HOME/.dotnet/tools" >> $GITHUB_PATH

      - name: 'DEV: Generate Database Migration Script'
        shell: bash
        if: inputs.db_migration_project_path != ''
        run: dotnet ef migrations script -o dev_migration_script.sql --project ${{ inputs.db_migration_project_path }} --idempotent
        env:
          DB_CONNECTION_STRING: ${{ secrets.DB_CONNECTION_STRING }}

      - name: 'DEV: Generate Infrastructure Plan'
        if: inputs.terraform_directory != ''
        uses: InwardEcho/workflow-templates/.github/actions/composite-terraform-iac@main
        with:
          working-directory: ${{ inputs.terraform_directory }}
          terraform-command: 'plan'
          environment-name: 'dev'
          var-file: 'terraform.dev.tfvars' # Ensure this var-file is correct for dev plan
          plan-output-file: 'dev.tfplan'
        env:
          AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

      - name: Upload DEV Terraform Plan
        if: inputs.terraform_directory != ''
        uses: actions/upload-artifact@v4
        with:
          name: dev-terraform-plan
          path: ${{ inputs.terraform_directory }}/dev.tfplan # Ensure path is correct relative to working-directory
          retention-days: 3

      - name: Upload DEV Migration Script
        if: inputs.db_migration_project_path != ''
        uses: actions/upload-artifact@v4
        with:
          name: dev-migration-script
          path: dev_migration_script.sql
          retention-days: 3

  # --- DEV Stage as a single job ---
  deploy_to_dev:
    name: 'Deploy to DEV Environment'
    needs: [determine_deployment_stages, plan_to_dev]
    if: needs.determine_deployment_stages.outputs.deploy_dev == 'true' && needs.plan_to_dev.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download DEV Terraform Plan
        if: inputs.terraform_directory != ''
        uses: actions/download-artifact@v4
        with:
          name: dev-terraform-plan
          path: ${{ inputs.terraform_directory }}

      - name: Download DEV Migration Script
        if: inputs.db_migration_project_path != ''
        uses: actions/download-artifact@v4
        with:
          name: dev-migration-script
          path: .

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        if: inputs.db_migration_project_path != ''
        with:
          dotnet-version: ${{ inputs.dotnet_version }}

      - name: Install SQLCMD Tools
        if: inputs.db_migration_project_path != ''
        shell: bash
        run: |
          echo "Attempting to install mssql-tools..."
          # Add Microsoft SQL Server repository
          curl https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add -
          curl https://packages.microsoft.com/config/ubuntu/$(lsb_release -rs)/prod.list | sudo tee /etc/apt/sources.list.d/mssql-release.list
          sudo apt-get update
          # Install SQL Server tools
          sudo ACCEPT_EULA=Y apt-get install -y mssql-tools unixodbc-dev
          echo "/opt/mssql-tools/bin" >> $GITHUB_PATH
          sqlcmd -? || (echo "::error::sqlcmd not found after attempting install" && exit 1)

      - name: 'DEV: Apply Infrastructure (Terraform)'
        if: inputs.terraform_directory != ''
        uses: InwardEcho/workflow-templates/.github/actions/composite-terraform-iac@main
        with:
          working-directory: ${{ inputs.terraform_directory }}
          terraform-command: 'apply'
          environment-name: 'dev'
          var-file: 'terraform.dev.tfvars'
          apply-auto-approve: true
          plan-output-file: 'dev.tfplan'
        env:
          AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

      - name: 'DEV: Apply Database Migration Script'
        if: inputs.db_migration_project_path != ''
        shell: bash
        run: |
          echo "Applying migration script dev_migration_script.sql"
          sqlcmd -S ${{ vars.DEV_DB_SERVER }} -d ${{ vars.DEV_DB_NAME }} -U ${{ vars.DEV_DB_USER }} -P "${{ secrets.DEV_DB_PASSWORD }}" -i dev_migration_script.sql -b -C
        env:
          SQL_PASSWORD: ${{ secrets.DEV_DB_PASSWORD }}

      - name: 'DEV: Deploy Application'
        id: deploy_app
        uses: InwardEcho/workflow-templates/.github/actions/composite-deploy-environment@main
        with:
          environment-name: 'dev'
          artifact-path: ${{ needs.determine_deployment_stages.outputs.artifact_name }}
          deployment-target-type: 'azure-app-service'
          version-being-deployed: ${{ needs.determine_deployment_stages.outputs.version }}
          azure-app-name: ${{ vars.azure_app_name }}-dev
        env:
          AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS_APP_SERVICE }}

      - name: 'DEV: Report Status'
        uses: InwardEcho/workflow-templates/.github/actions/composite-observability-hooks@main
        with:
          status: ${{ steps.deploy_app.outcome }}
          workflow-name: "${{ github.workflow }} - DEV Stage"
          environment-name: 'Development'
          version-deployed: ${{ needs.determine_deployment_stages.outputs.version }}
          run-url: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          message-details: "Deployment to Development status: ${{ steps.deploy_app.outcome }}."
          notification-channel: 'slack'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # --- TEST Stage as a single job ---
  deploy_to_test:
    name: 'Deploy to TEST Environment'
    needs: [determine_deployment_stages, deploy_to_dev]
    if: >
      needs.determine_deployment_stages.outputs.deploy_test == 'true' &&
      (
        needs.determine_deployment_stages.outputs.deploy_dev == 'false' ||
        (needs.determine_deployment_stages.outputs.deploy_dev == 'true' && needs.deploy_to_dev.result == 'success')
      )
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: 'TEST: Apply Infrastructure (Terraform)'
        uses: InwardEcho/workflow-templates/.github/actions/composite-terraform-iac@main
        with:
          working-directory: './Infra/test'
          terraform-command: 'apply'
          environment-name: 'test'
          var-file: 'terraform.test.tfvars'
          apply-auto-approve: false
        env:
          AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

      - name: 'TEST: Apply Database Migrations'
        uses: InwardEcho/workflow-templates/.github/actions/composite-efcore-migration@main
        with:
          efcore-project-path: ${{ needs.determine_deployment_stages.outputs.db_migration_project_path }}
          environment-name: 'test'
          backup-required: false
        env:
          DB_CONNECTION_STRING: ${{ secrets.DB_CONNECTION_STRING }}

      - name: 'TEST: Deploy Application'
        id: deploy_app
        uses: InwardEcho/workflow-templates/.github/actions/composite-deploy-environment@main
        with:
          environment-name: 'test'
          artifact-path: ${{ needs.determine_deployment_stages.outputs.artifact_name }}
          deployment-target-type: 'azure-app-service'
          version-being-deployed: ${{ needs.determine_deployment_stages.outputs.version }}
          azure-app-name: ${{ vars.TEST_AZURE_APP_NAME }}
        env:
          AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS_APP_SERVICE }}

      - name: 'TEST: Report Status'
        uses: InwardEcho/workflow-templates/.github/actions/composite-observability-hooks@main
        with:
          status: ${{ steps.deploy_app.outcome }}
          workflow-name: "${{ github.workflow }} - TEST Stage"
          environment-name: 'Test'
          version-deployed: ${{ needs.determine_deployment_stages.outputs.version }}
          run-url: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          message-details: "Deployment to Test status: ${{ steps.deploy_app.outcome }}."
          notification-channel: 'slack'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # --- PROD Stage as a single job ---
  deploy_to_prod:
    name: 'Deploy to PROD Environment'
    needs: [determine_deployment_stages, deploy_to_test]
    if: needs.determine_deployment_stages.outputs.deploy_prod == 'true' && needs.deploy_to_test.result == 'success'
    runs-on: ubuntu-latest
    outputs:
      canary_status: ${{ steps.canary_deployment.outputs.canary_status }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: 'PROD: Apply Infrastructure (Terraform)'
        uses: InwardEcho/workflow-templates/.github/actions/composite-terraform-iac@main
        with:
          working-directory: './Infra/prod'
          terraform-command: 'apply'
          environment-name: 'prod'
          var-file: 'terraform.prod.tfvars'
          apply-auto-approve: false
        env:
          AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

      - name: 'PROD: Apply Database Migrations'
        uses: InwardEcho/workflow-templates/.github/actions/composite-efcore-migration@main
        with:
          efcore-project-path: ${{ needs.determine_deployment_stages.outputs.db_migration_project_path }}
          environment-name: 'prod'
          backup-required: true
        env:
          DB_CONNECTION_STRING: ${{ secrets.DB_CONNECTION_STRING }}

      - name: 'PROD: Deploy Application'
        id: deploy_app
        uses: InwardEcho/workflow-templates/.github/actions/composite-deploy-environment@main
        with:
          environment-name: 'prod'
          artifact-path: ${{ needs.determine_deployment_stages.outputs.artifact_name }}
          deployment-target-type: 'azure-app-service'
          version-being-deployed: ${{ needs.determine_deployment_stages.outputs.version }}
          azure-app-name: ${{ vars.PROD_AZURE_APP_NAME }}
        env:
          AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS_APP_SERVICE }}

      - name: 'PROD: Report Status'
        uses: InwardEcho/workflow-templates/.github/actions/composite-observability-hooks@main
        with:
          status: ${{ steps.deploy_app.outcome }}
          workflow-name: "${{ github.workflow }} - PROD Stage"
          environment-name: 'prod'
          version-deployed: ${{ needs.determine_deployment_stages.outputs.version }}
          run-url: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          message-details: "Deployment to Prod status: ${{ steps.deploy_app.outcome }}."
          notification-channel: 'slack'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      # # For PROD, we need to implement the canary deployment process
      # # This would typically involve multiple steps using the composite actions
      # - name: 'PROD: Deploy Canary Slice'
      #   id: deploy_canary
      #   uses: InwardEcho/workflow-templates/.github/actions/composite-deploy-canary-slice@main
      #   with:
      #     environment-name: 'prod'
      #     artifact-path: ${{ needs.determine_deployment_stages.outputs.artifact_name }}
      #     version: ${{ needs.determine_deployment_stages.outputs.version }}
      #     canary-percentage: ${{ vars.PROD_CANARY_PERCENTAGE || 10 }}
      #     deployment-target-type: 'azure-app-service'
      #   env:
      #     AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS_APP_SERVICE }}

      # - name: 'PROD: Monitor Canary'
      #   id: monitor_canary
      #   uses: InwardEcho/workflow-templates/.github/actions/composite-monitor-canary@main
      #   with:
      #     environment-name: 'prod'
      #     health-check-url-canary: ${{ vars.PROD_CANARY_HEALTH_CHECK_URL_PATTERN }}
      #     observation-period-minutes: ${{ vars.PROD_CANARY_OBSERVATION_MINUTES || 30 }}
      #     version: ${{ needs.determine_deployment_stages.outputs.version }}

      # - name: 'PROD: Promote Canary'
      #   id: promote_canary
      #   if: steps.monitor_canary.outcome == 'success'
      #   uses: InwardEcho/workflow-templates/.github/actions/composite-promote-canary@main
      #   with:
      #     environment-name: 'prod'
      #     version: ${{ needs.determine_deployment_stages.outputs.version }}
      #     deployment-target-type: 'azure-app-service'
      #   env:
      #     AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS_APP_SERVICE }}

      # - name: 'PROD: Rollback Canary'
      #   id: rollback_canary
      #   if: steps.monitor_canary.outcome == 'failure' && vars.PROD_CANARY_ROLLBACK_ON_FAILURE != 'false'
      #   uses: InwardEcho/workflow-templates/.github/actions/composite-rollback-canary@main
      #   with:
      #     environment-name: 'prod'
      #     deployment-target-type: 'azure-app-service'
      #   env:
      #     AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS_APP_SERVICE }}

      # - name: 'Set Canary Deployment Status'
      #   id: canary_deployment
      #   run: |
      #     if [[ "${{ steps.monitor_canary.outcome }}" == "success" && "${{ steps.promote_canary.outcome }}" == "success" ]]; then
      #       echo "canary_status=Succeeded and promoted to 100%" >> $GITHUB_OUTPUT
      #     elif [[ "${{ steps.monitor_canary.outcome }}" == "failure" && "${{ steps.rollback_canary.outcome }}" == "success" ]]; then
      #       echo "canary_status=Failed and rolled back" >> $GITHUB_OUTPUT
      #     elif [[ "${{ steps.monitor_canary.outcome }}" == "failure" ]]; then
      #       echo "canary_status=Failed" >> $GITHUB_OUTPUT
      #     else
      #       echo "canary_status=Unknown state" >> $GITHUB_OUTPUT
      #     fi

      # - name: 'PROD: Report Status'
      #   uses: InwardEcho/workflow-templates/.github/actions/composite-observability-hooks@main
      #   with:
      #     status: ${{ steps.canary_deployment.outcome }}
      #     workflow-name: "${{ github.workflow }} - PROD Stage"
      #     environment-name: 'Production'
      #     version-deployed: ${{ needs.determine_deployment_stages.outputs.version }}
      #     run-url: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
      #     message-details: "Deployment to Production status: ${{ steps.canary_deployment.outcome }}. Canary outcome: ${{ steps.canary_deployment.outputs.canary_status }}"
      #     notification-channel: 'slack'
      #   env:
      #     SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}