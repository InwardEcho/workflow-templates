# Continuous Deployment to PRODUCTION Environment Workflow
# Filename: .github/workflows/cd-prod-environment.yml
# Purpose: Deploys a version (validated in TEST) to the PRODUCTION environment,
#          using a canary strategy and incorporating manual approvals via GitHub Environments.

name: CD - PROD Environment

on:
  workflow_dispatch: # For manual triggering or promotion from TEST
    inputs:
      version_to_deploy:
        description: 'Version to deploy to PRODUCTION (e.g., 1.2.3)'
        required: true
        type: string
      source_artifact_name:
        description: 'Name of the build artifact to download (e.g., release-1.2.3-app-package)'
        required: true
        type: string
  # workflow_run: # Triggered by cd-test-environment.yml
  #   workflows: ["CD - TEST Environment"] # Name of the cd-test-environment.yml workflow
  #   types:
  #     - completed

permissions:
  contents: read
  actions: read      # No further workflows triggered from here in this design
  id-token: write    # For OIDC with cloud providers
  # deployments: write # If creating GitHub Deployment entities

concurrency:
  group: ${{ github.workflow }}-prod-${{ github.event.inputs.version_to_deploy || github.sha }}
  cancel-in-progress: false # PRODUCTION deployments should not be auto-cancelled lightly

env:
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  # PROD_ENVIRONMENT_URL: ${{ vars.PROD_ENVIRONMENT_URL }}

jobs:
  prepare_prod_deployment_info:
    name: Prepare PROD Deployment Information
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get_info.outputs.version }}
      artifact_name: ${{ steps.get_info.outputs.artifact_name }}

    steps:
      - name: Consolidate Trigger Info
        id: get_info
        shell: bash
        run: |
          VERSION=""
          ARTIFACT_NAME=""

          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "Triggered by workflow_dispatch for PROD"
            VERSION="${{ github.event.inputs.version_to_deploy }}"
            ARTIFACT_NAME="${{ github.event.inputs.source_artifact_name }}"
          elif [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            echo "Triggered by workflow_run from workflow: ${{ github.event.workflow_run.name }} for PROD"
            if [[ "${{ github.event.workflow_run.conclusion }}" == "success" ]]; then
              echo "::warning::Fetching parameters from workflow_run artifacts for PROD CD is complex."
              # Placeholder: Logic to download and parse a parameters artifact from the triggering cd-test-environment run.
              echo "::error::Direct parameter passing from workflow_run is not used in this template for PROD. Expecting workflow_dispatch inputs."
              exit 1 # Or handle differently
            else
              echo "::error::Triggering TEST CD workflow (${{ github.event.workflow_run.name }}) did not succeed. Halting PROD deployment."
              exit 1
            fi
          fi

          if [[ -z "$VERSION" || -z "$ARTIFACT_NAME" ]]; then
            echo "::error::Version or Artifact Name is missing for PROD deployment. Cannot proceed."
            exit 1
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "artifact_name=$ARTIFACT_NAME" >> $GITHUB_OUTPUT
          
          echo "Deploying Version to PROD: $VERSION"
          echo "Using Artifact for PROD: $ARTIFACT_NAME"

  deploy_to_prod:
    name: Deploy to PRODUCTION Environment (Canary)
    runs-on: ubuntu-latest
    needs: prepare_prod_deployment_info
    if: needs.prepare_prod_deployment_info.outputs.version != ''
    environment:
      name: Production # This MUST match a configured GitHub Environment for approvals
      url: ${{ vars.PROD_ENVIRONMENT_URL || format('https://www.example.com/app-{0}', needs.prepare_prod_deployment_info.outputs.version) }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download Application Artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.prepare_prod_deployment_info.outputs.artifact_name }}
          path: ./app-to-deploy

      - name: Apply PROD Infrastructure (Terraform)
        id: terraform_prod
        uses: ./.github/workflows/reusable-iac-terraform.yml
        with:
          working-directory: './Infra/prod' # Example
          terraform-command: 'apply' # Could be 'plan' first, then a manual approval for apply if desired
          environment: 'prod'
          var-file: 'terraform.prod.tfvars' # Example
          apply-auto-approve: false # PROD should always have plan review or manual apply step
        secrets:
          AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID_PROD }}
          AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET_PROD }}
          AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID_PROD }}
          AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID_PROD }}

      - name: Apply PROD Database Migrations
        id: db_migration_prod
        # Consider if this runs before canary, during, or as part of blue/green cutover
        if: steps.terraform_prod.outputs.status == 'success'
        uses: ./.github/workflows/reusable-database-migration-efcore.yml
        with:
          efcore-project-path: 'src/MyProject.DataAccess/MyProject.DataAccess.csproj' # Example
          environment: 'prod'
          connection-string: ${{ secrets.PROD_DB_CONNECTION_STRING }} # Direct secret passing
          backup-required: true
        secrets:
          _placeholder_for_secret_passing_to_reusable: "Ensure reusable workflow handles this correctly"

      - name: Canary Deploy Application to PROD
        id: app_canary_deploy_prod
        if: steps.db_migration_prod.outputs.status == 'success' # Or appropriate preceding step
        uses: ./.github/workflows/reusable-canary-deployment.yml
        with:
          environment-name: 'prod' # Base name for canary slice identification
          artifact-path: './app-to-deploy'
          version: ${{ needs.prepare_prod_deployment_info.outputs.version }}
          canary-percentage: ${{ vars.PROD_CANARY_PERCENTAGE || 10 }} # Configurable via GitHub Variable
          observation-period-minutes: ${{ vars.PROD_CANARY_OBSERVATION_MINUTES || 30 }} # Configurable
          health-check-url-pattern: ${{ vars.PROD_CANARY_HEALTH_CHECK_URL_PATTERN }} # e.g., https://prod-canary.example.com/api/health
          primary-deployment-target-type: 'azure-app-service' # Example
          # Target-specific inputs for canary and primary, e.g.:
          # azure-app-name-production-slot: ${{ vars.PROD_AZURE_APP_NAME_SLOT_PROD }}
          # azure-app-name-canary-slot: ${{ vars.PROD_AZURE_APP_NAME_SLOT_CANARY }}
          # azure-app-name: ${{ vars.PROD_AZURE_APP_NAME }}
          rollback-on-failure: true
        secrets:
          AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS_PROD_APP_SERVICE }}

  report_prod_cd_status:
    name: Report PROD CD Status
    runs-on: ubuntu-latest
    needs: [prepare_prod_deployment_info, deploy_to_prod]
    if: always()

    steps:
      - name: Notify PROD CD Status
        uses: ./.github/workflows/reusable-observability-hooks.yml
        with:
          status: ${{ needs.deploy_to_prod.result }}
          workflow-name: "${{ github.workflow }} - PROD"
          environment-name: 'Production'
          version-deployed: ${{ needs.prepare_prod_deployment_info.outputs.version }}
          run-url: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          message-details: "Deployment to PRODUCTION environment status: ${{ needs.deploy_to_prod.result }}. Canary outcome: ${{ needs.deploy_to_prod.outputs.canary_status }}" # Assuming canary workflow outputs its status
          notification-channel: 'slack' # Critical notifications
        secrets:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL_DEPLOYMENTS_CRITICAL }}