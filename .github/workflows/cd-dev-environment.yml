# Continuous Deployment to DEV Environment Workflow
# Filename: .github/workflows/cd-dev-environment.yml
# Purpose: Deploys a specific version/artifact to the DEV environment.
#          If triggered from a main branch CI, it will then trigger the TEST CD workflow.

name: CD - DEV Environment

on:
  workflow_dispatch: # For manual triggering
    inputs:
      version_to_deploy:
        description: 'Version to deploy (e.g., 1.2.3 or 1.2.3-feature-xyz.5)'
        required: true
        type: string
      source_artifact_name:
        description: 'Name of the build artifact to download (e.g., release-1.2.3-app-package)'
        required: true
        type: string
      source_branch_is_main:
        description: 'Was the CI source the main branch? (true/false)'
        required: true
        type: boolean # Keep as boolean for direct use in if conditions
        default: false
  # workflow_run: # Alternative trigger from ci-unified.yml (requires different input handling)
  #   workflows: ["Unified CI"] # Name of the ci-unified.yml workflow
  #   types:
  #     - completed

permissions:
  contents: read      # To checkout code (if reusable workflows need it for context)
  actions: write       # To trigger cd-test-environment.yml
  id-token: write      # For OIDC with cloud providers (e.g., Azure, AWS, GCP)
  # deployments: write # If creating GitHub Deployment entities

concurrency:
  group: ${{ github.workflow }}-dev-${{ github.event.inputs.version_to_deploy || github.sha }} # Use SHA for workflow_run if inputs not directly available
  cancel-in-progress: false # DEV deployments should ideally complete or fail clearly

env:
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  # DEV_ENVIRONMENT_URL: ${{ vars.DEV_ENVIRONMENT_URL }} # Example from design

jobs:
  prepare_deployment_info:
    name: Prepare DEV Deployment Information
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get_info.outputs.version }}
      artifact_name: ${{ steps.get_info.outputs.artifact_name }}
      is_main_pipeline: ${{ steps.get_info.outputs.is_main_pipeline }}

    steps:
      - name: Consolidate Trigger Info
        id: get_info
        shell: bash
        run: |
          VERSION=""
          ARTIFACT_NAME=""
          IS_MAIN_PIPELINE="false" # Default to string 'false' for easier comparison in `if`

          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "Triggered by workflow_dispatch"
            VERSION="${{ github.event.inputs.version_to_deploy }}"
            ARTIFACT_NAME="${{ github.event.inputs.source_artifact_name }}"
            # Convert boolean input to string 'true'/'false' for consistent output
            [[ "${{ github.event.inputs.source_branch_is_main }}" == "true" ]] && IS_MAIN_PIPELINE="true"
          elif [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            echo "Triggered by workflow_run from workflow: ${{ github.event.workflow_run.name }}"
            if [[ "${{ github.event.workflow_run.conclusion }}" == "success" ]]; then
              echo "::warning::Fetching parameters from workflow_run artifacts is complex."
              echo "::warning::This example assumes parameters were passed via inputs to a manual dispatch, or ci-unified.yml created a known artifact."
              # Placeholder: Logic to download and parse a parameters artifact from the triggering workflow_run
              # This would involve using actions/download-artifact with the triggering run's ID and a known artifact name.
              # For now, we'll simulate this by trying to use inputs that *would* have been in such an artifact.
              # This part needs robust implementation based on how ci-unified.yml makes data available.
              # If ci-unified.yml used workflow_dispatch to call this, inputs would be available.
              # If this workflow is triggered by workflow_run, the 'inputs' are not directly from the triggering workflow's inputs.
              # We'll assume for now that if it's a workflow_run, the calling workflow (ci-unified)
              # has correctly dispatched *this* workflow with the necessary inputs.
              # This means the workflow_dispatch inputs defined above are what we expect.
              # This section is more of a note for future robust implementation of workflow_run parameter passing.
              echo "::error::Direct parameter passing from workflow_run is not used in this template. Expecting workflow_dispatch inputs."
              exit 1 # Or handle differently if workflow_run is the primary trigger
            else
              echo "::error::Triggering CI workflow (${{ github.event.workflow_run.name }}) did not succeed. Halting DEV deployment."
              exit 1
            fi
          fi

          if [[ -z "$VERSION" || -z "$ARTIFACT_NAME" ]]; then
            echo "::error::Version or Artifact Name is missing. Cannot proceed."
            exit 1
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "artifact_name=$ARTIFACT_NAME" >> $GITHUB_OUTPUT
          echo "is_main_pipeline=$IS_MAIN_PIPELINE" >> $GITHUB_OUTPUT
          
          echo "Deploying Version: $VERSION"
          echo "Using Artifact: $ARTIFACT_NAME"
          echo "Is Main Pipeline: $IS_MAIN_PIPELINE"

  deploy_to_dev:
    name: Deploy to DEV Environment
    runs-on: ubuntu-latest
    needs: prepare_deployment_info
    if: needs.prepare_deployment_info.outputs.version != '' # Ensure version is set
    environment:
      name: Development # This should match a GitHub Environment if you use them for secrets/protection rules
      url: ${{ vars.DEV_ENVIRONMENT_URL || format('https://dev.example.com/app-{0}', needs.prepare_deployment_info.outputs.version) }}

    steps:
      - name: Checkout repository (for context, if reusable workflows need it)
        uses: actions/checkout@v4

      - name: Download Application Artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.prepare_deployment_info.outputs.artifact_name }}
          path: ./app-to-deploy # Download to a known location

      - name: Apply DEV Infrastructure (Terraform)
        id: terraform_dev
        uses: ./.github/workflows/reusable-iac-terraform.yml
        with:
          working-directory: './Infra/dev' # Example path, adjust to your project structure
          terraform-command: 'apply'
          environment: 'dev'
          # backend-config-file: 'backend-dev.config' # Example
          var-file: 'terraform.dev.tfvars' # Example
          apply-auto-approve: true
        secrets:
          # Pass cloud provider credentials specific to DEV
          AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID_DEV }}
          AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET_DEV }}
          AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID_DEV }}
          AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID_DEV }}

      - name: Apply DEV Database Migrations
        id: db_migration_dev
        if: steps.terraform_dev.outputs.status == 'success' # Only run if infra is ready
        uses: ./.github/workflows/reusable-database-migration-efcore.yml
        with:
          efcore-project-path: 'src/MyProject.DataAccess/MyProject.DataAccess.csproj' # Example
          environment: 'dev'
          connection-string: ${{ secrets.DEV_DB_CONNECTION_STRING }} # Pass the actual secret value
          backup-required: false # Typically no backup for dev
        secrets:
          # This reusable workflow expects the connection string via its own 'connection-string' input,
          # but the secret itself is defined in the caller.
          # The 'connection-string' input in the reusable workflow is a bit of a misnomer if it's taking the actual string.
          # Let's assume the reusable workflow is adapted to take the secret name, or we pass the secret value directly.
          # For clarity, the reusable workflow should define a secret input, e.g., ACTUAL_DB_CONNECTION_STRING
          # And here we would pass: ACTUAL_DB_CONNECTION_STRING: ${{ secrets.DEV_DB_CONNECTION_STRING }}
          # For now, matching the design doc where reusable takes `connection-string` as input value:
          _placeholder_for_secret_passing_to_reusable: "Ensure reusable workflow handles this correctly"


      - name: Deploy Application to DEV
        id: app_deploy_dev
        if: steps.db_migration_dev.outputs.status == 'success' # Only run if DB migration is done
        uses: ./.github/workflows/reusable-deploy-environment.yml
        with:
          environment-name: 'dev'
          artifact-path: './app-to-deploy' # Path where artifact was downloaded
          deployment-target-type: 'azure-app-service' # Example
          version-being-deployed: ${{ needs.prepare_deployment_info.outputs.version }}
          azure-app-name: ${{ vars.DEV_AZURE_APP_NAME }} # Example from GitHub Variables
          # health-check-url: ${{ vars.DEV_HEALTH_CHECK_URL }}
        secrets:
          AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS_DEV_APP_SERVICE }} # Specific creds for app service deployment

  trigger_test_deployment:
    name: Trigger TEST Deployment
    runs-on: ubuntu-latest
    needs: [prepare_deployment_info, deploy_to_dev]
    if: success() && needs.prepare_deployment_info.outputs.is_main_pipeline == 'true' && needs.deploy_to_dev.result == 'success'

    steps:
      - name: Dispatch TEST Deployment Workflow
        uses: benc-uk/workflow-dispatch@v1
        with:
          workflow: cd-test-environment.yml
          token: ${{ secrets.WORKFLOW_DISPATCH_PAT }}
          inputs: |
            {
              "version_to_deploy": "${{ needs.prepare_deployment_info.outputs.version }}",
              "source_artifact_name": "${{ needs.prepare_deployment_info.outputs.artifact_name }}"
            }
          ref: ${{ github.ref }} # Or main branch ref if appropriate

  report_dev_cd_status:
    name: Report DEV CD Status
    runs-on: ubuntu-latest
    needs: [prepare_deployment_info, deploy_to_dev]
    if: always()

    steps:
      - name: Notify DEV CD Status
        uses: ./.github/workflows/reusable-observability-hooks.yml
        with:
          status: ${{ needs.deploy_to_dev.result }} # Overall status of the deploy_to_dev job
          workflow-name: "${{ github.workflow }} - DEV"
          environment-name: 'Development'
          version-deployed: ${{ needs.prepare_deployment_info.outputs.version }}
          run-url: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          message-details: "Deployment to DEV environment status: ${{ needs.deploy_to_dev.result }}"
          notification-channel: 'slack' # Or your preferred channel
        secrets:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL_DEPLOYMENTS }}